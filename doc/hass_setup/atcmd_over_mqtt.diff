diff --git a/component/at_cmd/CMakeLists.txt b/component/at_cmd/CMakeLists.txt
index 68e9bd22..3a3a13a6 100644
--- a/component/at_cmd/CMakeLists.txt
+++ b/component/at_cmd/CMakeLists.txt
@@ -39,6 +39,7 @@ set(private_compile_options)         #private compile_options
 #NOTE: User defined section, add your private build configures here
 # You may use if-else condition to set these predefined variable
 ameba_list_append(private_sources monitor.c)
+ameba_list_append(private_includes ${c_CMPT_EXAMPLE_DIR}/network_protocol/mqtt)
 
 if(CONFIG_CORE_AS_AP AND CONFIG_SUPPORT_ATCMD)
     ameba_list_append(private_sources
@@ -48,6 +49,7 @@ if(CONFIG_CORE_AS_AP AND CONFIG_SUPPORT_ATCMD)
         atcmd_bt_mp.c
         atcmd_coex.c
         atcmd_otp.c
+        at_intf_split.c
     )
     ameba_list_append_if(CONFIG_WLAN private_sources
         atcmd_http.c
@@ -57,6 +59,7 @@ if(CONFIG_CORE_AS_AP AND CONFIG_SUPPORT_ATCMD)
         atcmd_sockets.c
         atcmd_websocket.c
         atcmd_wifi.c
+#        atcmd_hems.c
     )
     ameba_list_append_if(CONFIG_BT private_sources
         atcmd_bt_ext.c
diff --git a/component/at_cmd/at_intf_split.c b/component/at_cmd/at_intf_split.c
new file mode 100644
index 00000000..a5b18530
--- /dev/null
+++ b/component/at_cmd/at_intf_split.c
@@ -0,0 +1,34 @@
+/*
+
+Interface to fork ATCMD output to both UART and over MQTT transport
+
+Requires MQTT example to be running in order to publish over MQTT
+
+*/
+
+#include "at_intf_uart.h"
+#include "at_intf_split.h"
+#include "atcmd_service.h"
+#include "MQTTClient.h"
+#include "example_mqtt.h"
+
+extern void atio_uart_output(char *buf, int len);
+
+void atio_split_output(char *buf, int len) {
+    // write to uart output if enabled
+#if defined(SPLIT_ENABLE_UART_OUTPUT) && (SPLIT_ENABLE_UART_OUTPUT == 1)
+    RTK_LOGS(NOTAG, RTK_LOG_ALWAYS, buf);
+#endif
+
+    // then write to mqtt publish
+    RTK_LOGI(NOTAG, "[%s] publishing atcmd output\n", __FUNCTION__);
+    wrap_mqtt_publish_message(buf, len);
+}
+
+int atio_split_init(void)
+{
+	out_buffer = atio_split_output;
+	RTK_LOGI(NOTAG, "[%s] out_buffer set to split buffer\n", __FUNCTION__);
+
+	return 0;
+}
\ No newline at end of file
diff --git a/component/at_cmd/at_intf_split.h b/component/at_cmd/at_intf_split.h
new file mode 100644
index 00000000..12821eb2
--- /dev/null
+++ b/component/at_cmd/at_intf_split.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) 2024 Realtek Semiconductor Corp.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef AT_INTF_SPLIT_H
+#define AT_INTF_SPLIT_H
+
+#include "ameba_soc.h"
+
+#define SPLIT_ENABLE_UART_OUTPUT 1
+
+_LONG_CALL_ void atio_split_output(char *buf, int len);
+_LONG_CALL_ int atio_split_init(void);
+
+#endif /* AT_INTF_SPLIT_H */
\ No newline at end of file
diff --git a/component/at_cmd/atcmd_service.c b/component/at_cmd/atcmd_service.c
index 2375eecb..d793c636 100644
--- a/component/at_cmd/atcmd_service.c
+++ b/component/at_cmd/atcmd_service.c
@@ -13,6 +13,7 @@
 #include "at_intf_uart.h"
 #include "at_intf_spi.h"
 #include "at_intf_sdio.h"
+#include "at_intf_split.h"
 #include "atcmd_service.h"
 #include "vfs.h"
 #include "kv.h"
@@ -51,6 +52,8 @@
 #include "atcmd_otp.h"
 #endif
 
+//#include "atcmd_hems.h"
+
 //======================================================
 struct list_head log_hash[ATC_INDEX_NUM];
 
@@ -103,8 +106,59 @@ log_init_t log_init_table[] = {
 #ifndef CONFIG_AMEBAD
 	at_otp_init,
 #endif
+	//at_hems_init,
 };
 
+char global_buf[SMALL_BUF];
+at_write out_buffer;
+int at_printf(const char *fmt, ...)
+{
+	int ret = -1;
+	int len_fmt = 0;
+	char *buf;
+
+	at_printf_lock();
+
+	va_list ap;
+	va_start(ap, fmt);
+	len_fmt = vsnprintf(global_buf, SMALL_BUF, fmt, ap);
+	va_end(ap);
+
+	if (len_fmt < 0) {
+		goto fail;
+	}
+
+	if (len_fmt < SMALL_BUF) {
+		buf = global_buf;
+	} else if (len_fmt < MAX_BUF_LEN) {
+		buf = (char *)rtos_mem_malloc(len_fmt + 1);
+		if (buf == NULL) {
+			goto fail;
+		}
+
+		va_start(ap, fmt);
+		vsnprintf(buf, len_fmt + 1, fmt, ap);
+		va_end(ap);
+	} else {
+		RTK_LOGE(TAG, "print string len %d exceed max buffer length : %d\n", (int)len_fmt, MAX_BUF_LEN);
+		goto fail;
+	}
+
+	ret = len_fmt;
+
+	if (out_buffer) {
+		out_buffer(buf, len_fmt);
+	}
+
+	if (len_fmt >= SMALL_BUF) {
+		rtos_mem_free(buf);
+	}
+
+fail:
+	at_printf_unlock();
+	return ret;
+}
+
 
 //======================================================
 #ifdef CONFIG_ATCMD_HOST_CONTROL
@@ -664,6 +718,8 @@ void atcmd_service_init(void)
 
 	rtos_mutex_recursive_create(&at_printf_mutex);
 
+	atio_split_init();
+
 #ifdef CONFIG_ATCMD_HOST_CONTROL
 	rtos_timer_create(&xTimers_TT_Mode, "TT_Mode_Timer", NULL, 30, FALSE, tt_mode_timeout_handler);
 
diff --git a/component/at_cmd/atcmd_service.h b/component/at_cmd/atcmd_service.h
index 1bba29b6..8962a42b 100644
--- a/component/at_cmd/atcmd_service.h
+++ b/component/at_cmd/atcmd_service.h
@@ -100,6 +100,9 @@ enum {
 	AT_HOST_CONTROL_UART = 1,
 	AT_HOST_CONTROL_SPI,
 	AT_HOST_CONTROL_SDIO,
+
+	// FOR ATCMD SPLIT MQTT
+	AT_HOST_CONTROL_SPLIT_UART_MQTT,
 };
 
 int atcmd_get_ssl_certificate(char *buffer, CERT_TYPE cert_type, int index);
@@ -114,7 +117,10 @@ extern at_write out_buffer;
 int at_printf(const char *fmt, ...);
 int at_printf_indicate(const char *fmt, ...);
 #else
-#define at_printf(fmt, args...)    RTK_LOGS(NOTAG, RTK_LOG_ALWAYS, fmt, ##args)
+//#define at_printf(fmt, args...)    RTK_LOGS(NOTAG, RTK_LOG_ALWAYS, fmt, ##args)
+typedef void (*at_write)(char *buf, int len);
+extern at_write out_buffer;
+extern int at_printf(const char *fmt, ...);
 #define at_printf_indicate(fmt, args...) \
 		RTK_LOGS(NOTAG, RTK_LOG_ALWAYS, "[$]");\
 		RTK_LOGS(NOTAG, RTK_LOG_ALWAYS, fmt, ##args)
diff --git a/component/example/network_protocol/mqtt/example_mqtt.c b/component/example/network_protocol/mqtt/example_mqtt.c
index 6eb31a7c..a1597473 100644
--- a/component/example/network_protocol/mqtt/example_mqtt.c
+++ b/component/example/network_protocol/mqtt/example_mqtt.c
@@ -2,11 +2,44 @@
 #include "MQTTClient.h"
 
 #define MQTT_SELECT_TIMEOUT 1
+#define MQTT_TASK
 
+#define MQTT_ATCMD_SUBTOPIC_STR "Ameba/DPlus/ATCMD/Request"
+#define MQTT_ATCMD_PUBTOPIC_STR "Ameba/DPlus/ATCMD/Response"
+#define MQTT_BROKER_USERNAME "dplus"
+#define MQTT_BROKER_PASSWORD "ameba"
+#define MQTT_BROKER_ADDRESS "192.168.40.133"
+
+static const char* atcmd_header = "AT+";
+static const char* atcmd_statecmd = "AT+STATE";
+
+static MQTTClient client;
+
+void MQTTPublishMessage(MQTTClient *c, char *topic, char* to_send, uint32_t len);
+
+void wrap_mqtt_publish_message(char *buf, uint32_t len) {
+	MQTTPublishMessage(&client, MQTT_ATCMD_PUBTOPIC_STR, buf, len);
+}
+
+extern void at_state(void *arg);
 static void messageArrived(MessageData *data, void *discard)
 {
 	(void)discard;
-	mqtt_printf(MQTT_INFO, "Message arrived on topic %s: %s\n", data->topicName->lenstring.data, (char *)data->message->payload);
+	//mqtt_printf(MQTT_INFO, "Message arrived on topic %s: %s\n", data->topicName->lenstring.data, (char *)data->message->payload);
+	char buf[128] = { 0 };
+	memcpy(buf, data->topicName->lenstring.data, data->topicName->lenstring.len);
+	mqtt_printf(MQTT_INFO, "Message arrived on topic %s: %s\n", buf, (char *)data->message->payload);
+	
+	if (memcmp(data->message->payload, atcmd_header, strlen(atcmd_header)) == 0) {
+		mqtt_printf(MQTT_INFO, "Processing atcmd...\n");
+
+		// run the ATCMD, it will write to UART then publish a mqtt message
+		if (memcmp(data->message->payload, atcmd_statecmd, strlen(atcmd_statecmd)) == 0) {
+			at_state(NULL);
+		}
+
+		// MQTTPublishMessage(&client, MQTT_ATCMD_PUBTOPIC_STR, test_msg, strlen(test_msg));
+	}
 }
 
 //This example is original and cannot restart if failed. To use this example, define WAIT_FOR_ACK and not define MQTT_TASK in MQTTClient.h
@@ -21,9 +54,22 @@ void prvMQTTEchoTask(void *pvParameters)
 	unsigned char sendbuf[512], readbuf[80];
 	int rc = 0, count = 0;
 	MQTTPacket_connectData connectData = MQTTPacket_connectData_initializer;
-	const char *address = "broker.emqx.io";
-	const char *sub_topic = "LASS/Test/Pm25Ameba/#";
-	const char *pub_topic = "LASS/Test/Pm25Ameba/FT1_018";
+	//connectData.username = "dplus";
+	//connectData.password = "ameba";
+	MQTTString mqttUsername = MQTTString_initializer;
+	mqttUsername.cstring = "dplus";
+	MQTTString mqttPassword = MQTTString_initializer;
+	mqttPassword.cstring = "ameba";
+	connectData.username = mqttUsername;
+	connectData.password = mqttPassword;
+	
+	//const char *address = "broker.emqx.io";
+	//const char *sub_topic = "LASS/Test/Pm25Ameba/#";
+	//const char *pub_topic = "LASS/Test/Pm25Ameba/FT1_018";
+
+	const char *address = "192.168.40.133";
+	const char *sub_topic = "Ameba/DPlus/ATCMD/#";
+	const char *pub_topic = "Ameba/DPlus/ATCMD/Response";
 
 	memset(readbuf, 0x00, sizeof(readbuf));
 
@@ -43,7 +89,7 @@ void prvMQTTEchoTask(void *pvParameters)
 	mqtt_printf(MQTT_INFO, "\"%s\" Connected", address);
 
 	connectData.MQTTVersion = 3;
-	connectData.clientID.cstring = (char *)"FT1_018";
+	connectData.clientID.cstring = (char *)"DPlus";
 
 	mqtt_printf(MQTT_INFO, "Start MQTT connection");
 	while ((rc = MQTTConnect(&client, &connectData)) != 0) {
@@ -84,10 +130,10 @@ void prvMQTTEchoTask(void *pvParameters)
 }
 
 #if defined(MQTT_TASK)
-void MQTTPublishMessage(MQTTClient *c, char *topic)
+void MQTTPublishMessage(MQTTClient *c, char *topic, char* to_send, uint32_t len)
 {
 	int rc = 0;
-	static int count = 0;
+	//static int count = 0;
 	MQTTMessage message;
 	char payload[300];
 	message.qos = QOS1;
@@ -95,14 +141,15 @@ void MQTTPublishMessage(MQTTClient *c, char *topic)
 	message.payload = payload;
 
 	if (c->mqttstatus == MQTT_RUNNING) {
-		count++;
-		sprintf(payload, "hello from AMEBA %d", count);
-		message.payloadlen = strlen(payload);
-		mqtt_printf(MQTT_INFO, "Publish Topic %s : %d", topic, count);
-		if ((rc = MQTTPublish(c, topic, &message)) != 0) {
-			mqtt_printf(MQTT_INFO, "Return code from MQTT publish is %d\n", rc);
-			MQTTSetStatus(c, MQTT_START);
-			c->ipstack->disconnect(c->ipstack);
+		if (len > 0 && len <= sizeof(payload)) {
+			sprintf(payload, to_send, len);
+			message.payloadlen = len;
+			mqtt_printf(MQTT_INFO, "Publish Topic %s", topic);
+			if ((rc = MQTTPublish(c, topic, &message)) != 0) {
+				mqtt_printf(MQTT_INFO, "Return code from MQTT publish is %d\n", rc);
+				MQTTSetStatus(c, MQTT_START);
+				c->ipstack->disconnect(c->ipstack);
+			}
 		}
 	}
 
@@ -113,16 +160,21 @@ static void prvMQTTTask(void *pvParameters)
 	/* To avoid gcc warnings */
 	(void) pvParameters;
 
-	MQTTClient client;
 	Network network;
 	static unsigned char sendbuf[MQTT_SENDBUF_LEN], readbuf[MQTT_READBUF_LEN];
 	int rc = 0, mqtt_pub_count = 0;
 	MQTTPacket_connectData connectData = MQTTPacket_connectData_initializer;
+	
+	MQTTString mqttUsername = MQTTString_initializer;
+	mqttUsername.cstring = MQTT_BROKER_USERNAME;
+	MQTTString mqttPassword = MQTTString_initializer;
+	mqttPassword.cstring = MQTT_BROKER_PASSWORD;
+	connectData.username = mqttUsername;
+	connectData.password = mqttPassword;
+	
 	connectData.MQTTVersion = 3;
-	connectData.clientID.cstring = (char *)"FT1_018";
-	const char *address = "broker.emqx.io";
-	const char *sub_topic = "LASS/Test/Pm25Ameba/#";
-	const char *pub_topic = "LASS/Test/Pm25Ameba/FT1_018";
+	connectData.clientID.cstring = (char *)"DPlus";
+	const char *address = MQTT_BROKER_ADDRESS;
 
 	NetworkInit(&network);
 	MQTTClientInit(&client, &network, 30000, sendbuf, sizeof(sendbuf), readbuf, sizeof(readbuf));
@@ -150,12 +202,12 @@ static void prvMQTTTask(void *pvParameters)
 				MQTTSetStatus(&client, MQTT_START); //my_socket will be close and reopen in MQTTDataHandle if STATUS set to MQTT_START
 			} else if (rc == 0) { //select timeout
 				if (++mqtt_pub_count == 5) { //Send MQTT publish message every 5 seconds
-					MQTTPublishMessage(&client, (char *)pub_topic);
+					//MQTTPublishMessage(&client, (char *)pub_topic);
 					mqtt_pub_count = 0;
 				}
 			}
 		}
-		MQTTDataHandle(&client, &read_fds, &connectData, messageArrived, (char *)address, (char *)sub_topic);
+		MQTTDataHandle(&client, &read_fds, &connectData, messageArrived, (char *)address, MQTT_ATCMD_SUBTOPIC_STR);
 	}
 }
 #endif
@@ -169,7 +221,6 @@ void vStartMQTTTasks(uint16_t usTaskStackSize, uint32_t uxTaskPriority)
 #else
 	rtos_task_create(NULL, "MQTTEcho0", prvMQTTEchoTask, (void *)x, (usTaskStackSize + 128) * 4, uxTaskPriority);
 #endif
-
 }
 
 void example_mqtt(void)
diff --git a/component/example/network_protocol/mqtt/example_mqtt.h b/component/example/network_protocol/mqtt/example_mqtt.h
index 5e4653b1..57c4dcbc 100644
--- a/component/example/network_protocol/mqtt/example_mqtt.h
+++ b/component/example/network_protocol/mqtt/example_mqtt.h
@@ -1,6 +1,10 @@
 #ifndef EXAMPLE_MQTT_H
 #define EXAMPLE_MQTT_H
 
+#include "ameba_soc.h"
+
 void example_mqtt(void);
 
+void wrap_mqtt_publish_message(char *buf, uint len);
+
 #endif /* EXAMPLE_MQTT_H */
